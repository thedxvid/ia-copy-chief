import { useState, useCallback, useEffect } from 'react';
import { ChatMessage, Agent, ChatState } from '@/types/chat';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';
import { useProducts } from './useProducts';
import { formatProductContext } from '@/utils/productContext';
import { useAuth } from '@/contexts/AuthContext';

interface ChatSession {
  id: string;
  title: string;
  created_at: string;
  messages: ChatMessage[];
  agent_name?: string;
  agent_id?: string;
  product_id?: string;
}

export const useChatAgent = (selectedProductId?: string) => {
  const [sessions, setSessions] = useState<ChatSession[]>([]);
  const [activeSession, setActiveSession] = useState<ChatSession | null>(null);
  const [selectedAgent, setSelectedAgent] = useState<Agent | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const { fetchProductDetails } = useProducts();
  const { user } = useAuth();

  // Lista de emails de administradores
  const adminEmails = ['davicastrowp@gmail.com', 'admin@iacopychief.com'];
  const isAdmin = user?.email && adminEmails.includes(user.email);

  useEffect(() => {
    if (user) {
      loadUserSessions();
    }
  }, [user]);

  const loadUserSessions = async () => {
    if (!user) return;

    try {
      console.log('Carregando sess√µes do usu√°rio:', user.id);
      
      const { data: sessionsData, error } = await supabase
        .from('chat_sessions')
        .select('*')
        .eq('user_id', user.id)
        .eq('is_active', true)
        .order('updated_at', { ascending: false });

      if (error) {
        console.error('Erro ao carregar sess√µes:', error);
        return;
      }

      console.log('Sess√µes encontradas:', sessionsData?.length || 0);

      const sessionsWithMessages = await Promise.all(
        (sessionsData || []).map(async (session) => {
          const { data: messagesData, error: messagesError } = await supabase
            .from('chat_messages')
            .select('*')
            .eq('session_id', session.id)
            .order('created_at', { ascending: true });

          if (messagesError) {
            console.error('Erro ao carregar mensagens:', messagesError);
          }

          const messages: ChatMessage[] = (messagesData || []).map(msg => ({
            id: msg.id,
            role: msg.role as 'user' | 'assistant',
            content: msg.content,
            timestamp: new Date(msg.created_at)
          }));

          return {
            id: session.id,
            title: session.title || 'Nova conversa',
            created_at: session.created_at,
            messages,
            agent_name: session.agent_name,
            agent_id: session.agent_id,
            product_id: session.product_id
          };
        })
      );

      console.log('Sess√µes processadas:', sessionsWithMessages.length);
      setSessions(sessionsWithMessages);
    } catch (error) {
      console.error('Erro geral ao carregar sess√µes:', error);
    }
  };

  const saveSessionToSupabase = async (session: ChatSession) => {
    if (!user) {
      console.log('Usu√°rio n√£o logado, n√£o salvando sess√£o');
      return null;
    }

    try {
      console.log('Salvando sess√£o:', session.id);
      
      // Determinar se √© agente customizado
      const isCustomAgent = selectedAgent?.id.startsWith('custom-');
      const actualAgentId = isCustomAgent 
        ? selectedAgent.id.replace('custom-', '') 
        : selectedAgent?.id || session.agent_id || '';
      
      const sessionData = {
        id: session.id,
        user_id: user.id,
        title: session.title,
        agent_name: selectedAgent?.name || session.agent_name || '',
        agent_id: actualAgentId,
        product_id: selectedProductId || session.product_id || null,
        is_active: true,
        message_count: session.messages.length,
        updated_at: new Date().toISOString()
      };

      const { data, error } = await supabase
        .from('chat_sessions')
        .upsert(sessionData)
        .select()
        .single();

      if (error) {
        console.error('Erro ao salvar sess√£o:', error);
        return null;
      }

      console.log('Sess√£o salva com sucesso:', data);
      return data;
    } catch (error) {
      console.error('Erro geral ao salvar sess√£o:', error);
      return null;
    }
  };

  const saveMessageToSupabase = async (sessionId: string, message: ChatMessage) => {
    if (!user) {
      console.log('Usu√°rio n√£o logado, n√£o salvando mensagem');
      return;
    }

    try {
      console.log('Salvando mensagem:', message.id);
      
      const { error } = await supabase
        .from('chat_messages')
        .insert({
          id: message.id,
          session_id: sessionId,
          role: message.role,
          content: message.content,
          tokens_used: 0
        });

      if (error) {
        console.error('Erro ao salvar mensagem:', error);
      } else {
        console.log('Mensagem salva com sucesso');
      }
    } catch (error) {
      console.error('Erro geral ao salvar mensagem:', error);
    }
  };

  const createNewSession = useCallback(async () => {
    const sessionId = crypto.randomUUID();
    
    const newSession: ChatSession = {
      id: sessionId,
      title: 'Nova conversa',
      created_at: new Date().toISOString(),
      messages: [],
      agent_name: selectedAgent?.name,
      agent_id: selectedAgent?.id,
      product_id: selectedProductId
    };
    
    console.log('Criando nova sess√£o:', sessionId);
    
    if (user) {
      const savedSession = await saveSessionToSupabase(newSession);
      if (savedSession) {
        console.log('Nova sess√£o salva no Supabase');
      }
    }
    
    setSessions(prev => [newSession, ...prev]);
    setActiveSession(newSession);
  }, [selectedAgent, selectedProductId, user]);

  const selectSession = useCallback((sessionId: string) => {
    console.log('Selecionando sess√£o:', sessionId);
    const session = sessions.find(s => s.id === sessionId);
    if (session) {
      setActiveSession(session);
    }
  }, [sessions]);

  const deleteSession = useCallback(async (sessionId: string) => {
    console.log('Deletando sess√£o:', sessionId);
    
    if (user) {
      try {
        const { error } = await supabase
          .from('chat_sessions')
          .update({ is_active: false })
          .eq('id', sessionId);
          
        if (error) {
          console.error('Erro ao deletar sess√£o:', error);
        } else {
          console.log('Sess√£o marcada como inativa no Supabase');
        }
      } catch (error) {
        console.error('Erro geral ao deletar sess√£o:', error);
      }
    }

    setSessions(prev => prev.filter(s => s.id !== sessionId));
    
    if (activeSession?.id === sessionId) {
      setActiveSession(null);
    }
    
    toast.success('Conversa exclu√≠da com sucesso');
  }, [activeSession, user]);

  const selectAgent = useCallback((agent: Agent) => {
    setSelectedAgent(agent);
  }, []);

  const sendMessage = useCallback(async (content: string) => {
    if (!selectedAgent) {
      toast.error('Selecione um agente antes de enviar uma mensagem');
      return;
    }

    if (!activeSession) {
      toast.error('Nenhuma sess√£o ativa');
      return;
    }

    const userMessageId = crypto.randomUUID();
    const userMessage: ChatMessage = {
      id: userMessageId,
      role: 'user',
      content,
      timestamp: new Date()
    };

    console.log('üì§ Enviando mensagem do usu√°rio:', userMessageId);

    const updatedSession = {
      ...activeSession,
      messages: [...activeSession.messages, userMessage],
      title: activeSession.messages.length === 0 
        ? content.length > 50 
          ? content.substring(0, 47) + '...' 
          : content
        : activeSession.title
    };
    
    setActiveSession(updatedSession);
    setSessions(prev => prev.map(s => s.id === activeSession.id ? updatedSession : s));
    
    if (user) {
      await saveMessageToSupabase(activeSession.id, userMessage);
      await saveSessionToSupabase(updatedSession);
    }
    
    setIsLoading(true);

    try {
      let productContext = '';
      let productDetails = null;
      
      // DEBUG: Verificar se temos produto selecionado
      console.log('üîç DEBUG - Produto selecionado:', {
        selectedProductId,
        hasProduct: !!selectedProductId
      });

      if (selectedProductId) {
        try {
          console.log('üîÑ DEBUG - Buscando detalhes do produto...');
          productDetails = await fetchProductDetails(selectedProductId);
          
          console.log('üìã DEBUG - Resultado da busca:', {
            productId: selectedProductId,
            productFound: !!productDetails,
            productName: productDetails?.name || 'N/A',
            hasAllData: !!(productDetails?.strategy || productDetails?.offer || productDetails?.copy || productDetails?.meta)
          });
          
          if (productDetails) {
            console.log('üîÑ DEBUG - Formatando contexto do produto...');
            productContext = formatProductContext(productDetails);
            
            console.log('‚úÖ DEBUG - Contexto formatado:', {
              contextLength: productContext.length,
              contextPreview: productContext.substring(0, 300) + '...',
              hasProductName: productContext.includes(productDetails.name),
              hasValueProposition: productContext.includes('Proposta de Valor'),
              hasTargetAudience: productContext.includes('P√∫blico-Alvo')
            });
          } else {
            console.warn('‚ö†Ô∏è DEBUG - Produto n√£o encontrado:', selectedProductId);
            toast.warning('Produto selecionado n√£o encontrado. Continuando sem contexto espec√≠fico.');
          }
        } catch (error) {
          console.error('‚ùå DEBUG - Erro ao buscar produto:', {
            productId: selectedProductId,
            error: error.message
          });
          toast.warning('Erro ao carregar contexto do produto. Continuando sem contexto espec√≠fico.');
        }
      } else {
        console.log('‚ÑπÔ∏è DEBUG - Nenhum produto selecionado');
      }

      let enhancedPrompt = selectedAgent.prompt;
      if (productContext && productContext.trim()) {
        enhancedPrompt = `${selectedAgent.prompt}

---
CONTEXTO DO PRODUTO SELECIONADO:
${productContext}

---
INSTRU√á√ïES IMPORTANTES:
- Use as informa√ß√µes do produto acima como contexto principal quando relevante
- Se o usu√°rio perguntar sobre criar conte√∫do para "meu produto" ou "esse produto", refira-se ao produto do contexto
- N√£o pergunte novamente sobre qual produto quando as informa√ß√µes j√° est√£o dispon√≠veis no contexto
- Mantenha consist√™ncia com a estrat√©gia e posicionamento definidos no produto
- Sempre que mencionar "seu produto", refira-se especificamente ao ${productDetails?.name}
`;

        console.log('üöÄ DEBUG - Prompt aprimorado com contexto:', {
          originalPromptLength: selectedAgent.prompt.length,
          enhancedPromptLength: enhancedPrompt.length,
          contextAdded: enhancedPrompt.length - selectedAgent.prompt.length,
          hasProductContext: enhancedPrompt.includes('CONTEXTO DO PRODUTO'),
          productName: productDetails?.name
        });
      } else {
        console.log('‚ÑπÔ∏è DEBUG - Usando prompt original sem contexto do produto');
      }

      // Determinar se √© agente customizado
      const isCustomAgent = selectedAgent?.id.startsWith('custom-');

      console.log('üöÄ DEBUG - Preparando chamada para IA:', {
        userId: user?.id,
        agentName: selectedAgent.name,
        isCustomAgent,
        hasProductContext: !!productContext,
        productId: selectedProductId,
        promptLength: enhancedPrompt.length
      });

      // Toast otimizado para processamento
      const loadingToast = toast.loading('ü§ñ Processando com contexto completo...', {
        duration: Infinity
      });

      const { data, error } = await supabase.functions.invoke('chat-with-claude', {
        body: {
          message: content,
          agentPrompt: enhancedPrompt,
          chatHistory: activeSession.messages.slice(-10).map(msg => ({
            role: msg.role,
            content: msg.content
          })),
          agentName: selectedAgent.name,
          isCustomAgent,
          customAgentId: isCustomAgent ? selectedAgent.id.replace('custom-', '') : null,
          productId: selectedProductId,
          userId: user?.id
        }
      });

      // Remover toast de loading
      toast.dismiss(loadingToast);

      console.log('üì• DEBUG - Resposta da fun√ß√£o:', { 
        hasData: !!data, 
        hasError: !!error,
        dataKeys: data ? Object.keys(data) : [],
        contextPreserved: data?.contextPreserved
      });

      if (error) {
        console.error('‚ùå Error calling chat function:', error);
        
        // Tratamento otimizado de erros
        let errorMessage = 'Erro tempor√°rio no chat. Tente novamente em alguns instantes.';
        
        if (error.message?.includes('Rate limit exceeded') || error.message?.includes('rate limit')) {
          errorMessage = 'üö¶ Muitas mensagens rapidamente. Aguarde 30 segundos e tente novamente.';
        } else if (error.message?.includes('network') || error.message?.includes('conectividade') || 
                   error.message?.includes('Failed to fetch')) {
          errorMessage = 'üåê Problema de conex√£o. Verifique sua internet e tente novamente.';
        } else if (error.message?.includes('503') || error.message?.includes('indispon√≠vel') || 
                   error.message?.includes('502')) {
          errorMessage = 'üîß Servi√ßo temporariamente indispon√≠vel. Tente novamente em 2 minutos.';
        } else if (error.message?.includes('Payload muito grande') || error.message?.includes('muito extensa')) {
          errorMessage = 'üìù Contexto muito extenso. Tente uma pergunta mais espec√≠fica.';
        }
        
        if (isAdmin) {
          console.log('üîß Debug admin - Erro detectado:', error);
          errorMessage += ` (Admin - Detalhes: ${error.message})`;
        }
        
        toast.error(errorMessage);
        return;
      }

      // Valida√ß√£o robusta da resposta
      if (!data) {
        console.error('‚ùå DEBUG - Resposta vazia da fun√ß√£o');
        toast.error('‚ùå Erro: Resposta vazia do servidor');
        return;
      }

      // Verificar se h√° erro na resposta
      if (data.error) {
        console.error('‚ùå DEBUG - Erro na resposta:', data.error);
        
        let errorMessage = 'Erro tempor√°rio no chat. Tente novamente.';
        
        if (data.error.includes('sobrecarregada')) {
          errorMessage = '‚è∞ A IA est√° sobrecarregada. Tente uma pergunta mais direta ou aguarde 30 segundos.';
        } else if (data.error.includes('Rate limit')) {
          errorMessage = 'üö¶ Muitas requisi√ß√µes simult√¢neas. Aguarde 10 segundos.';
        } else if (data.retryable === false) {
          errorMessage = '‚öôÔ∏è Erro de configura√ß√£o. Entre em contato com o suporte.';
        } else if (data.error.includes('indispon√≠vel') || data.error.includes('503') || data.error.includes('502')) {
          errorMessage = 'üîß Servi√ßo temporariamente indispon√≠vel. Tente novamente em 1 minuto.';
        } else if (data.error.includes('Contexto muito extenso')) {
          errorMessage = 'üìù Contexto muito longo. Tente ser mais conciso ou divida em partes.';
        }
        
        if (isAdmin) {
          errorMessage += ` (${data.details || data.error})`;
        }
        
        toast.error(errorMessage);
        return;
      }

      // Validar se a resposta cont√©m o campo correto
      const aiResponseText = data.response || data.generatedCopy || data.text;
      if (!aiResponseText || typeof aiResponseText !== 'string') {
        console.error('‚ùå DEBUG - Resposta inv√°lida:', data);
        toast.error('‚ùå Erro: Resposta inv√°lida do servidor');
        return;
      }

      const assistantMessageId = crypto.randomUUID();
      const assistantMessage: ChatMessage = {
        id: assistantMessageId,
        role: 'assistant',
        content: aiResponseText,
        timestamp: new Date()
      };

      console.log('üì® DEBUG - Resposta processada com sucesso:', {
        messageId: assistantMessageId,
        responseLength: aiResponseText.length,
        hadProductContext: !!productContext,
        contextPreserved: data.contextPreserved
      });

      const finalSession = {
        ...updatedSession,
        messages: [...updatedSession.messages, assistantMessage]
      };
      
      setActiveSession(finalSession);
      setSessions(prev => prev.map(s => s.id === activeSession.id ? finalSession : s));

      if (user) {
        await saveMessageToSupabase(activeSession.id, assistantMessage);
        await saveSessionToSupabase(finalSession);
      }

      // Toast de sucesso otimizado
      if (data.tokensUsed) {
        console.log(`‚úÖ Resposta gerada usando ${data.tokensUsed} tokens`);
        
        const getTokenIcon = (tokens: number) => {
          if (tokens > 4000) return 'üî•';
          if (tokens > 2000) return '‚ö°';
          return '‚ú®';
        };

        const tokenIcon = getTokenIcon(data.tokensUsed);
        
        const contextMessage = productContext 
          ? `An√°lise com contexto do produto ${productDetails?.name}`
          : 'An√°lise completa da documenta√ß√£o';
        
        toast.success(`${tokenIcon} Processamento completo!`, {
          description: `${data.tokensUsed.toLocaleString()} tokens ‚Ä¢ ${contextMessage}`,
          duration: 5000,
        });
      }

    } catch (error) {
      console.error('üí• Chat error:', error);
      
      // Tratamento de erro otimizado
      let errorMessage = '‚ùå Erro ao processar mensagem. Tente novamente.';
      
      if (error instanceof Error) {
        if (error.message.includes('network') || error.message.includes('fetch')) {
          errorMessage = 'üåê Problema de conex√£o. Verifique sua internet e tente novamente.';
        } else if (error.message.includes('abort')) {
          errorMessage = 'üõë Requisi√ß√£o cancelada. Tente novamente.';
        }
        
        if (isAdmin) {
          errorMessage += ` (Erro t√©cnico: ${error.message})`;
        }
      }
      
      toast.error(errorMessage);
    } finally {
      setIsLoading(false);
    }
  }, [selectedAgent, activeSession, selectedProductId, fetchProductDetails, user, isAdmin]);

  const regenerateLastMessage = useCallback(async () => {
    if (!activeSession || !selectedAgent) return;
    
    const messages = activeSession.messages;
    if (messages.length < 2) return;
    
    const lastUserMessage = messages[messages.length - 2];
    if (lastUserMessage.role !== 'user') return;
    
    const updatedMessages = messages.slice(0, -1);
    const updatedSession = {
      ...activeSession,
      messages: updatedMessages
    };
    
    setActiveSession(updatedSession);
    setSessions(prev => prev.map(s => s.id === activeSession.id ? updatedSession : s));
    
    await sendMessage(lastUserMessage.content);
  }, [activeSession, selectedAgent, sendMessage]);

  const clearChat = useCallback(() => {
    if (activeSession) {
      const clearedSession = {
        ...activeSession,
        messages: []
      };
      setActiveSession(clearedSession);
      setSessions(prev => prev.map(s => s.id === activeSession.id ? clearedSession : s));
    }
  }, [activeSession]);

  return {
    sessions,
    activeSession,
    createNewSession,
    selectSession,
    deleteSession,
    sendMessage,
    regenerateLastMessage,
    isLoading,
    selectedAgent,
    setSelectedAgent: selectAgent,
    clearChat,
    loadUserSessions
  };
};
